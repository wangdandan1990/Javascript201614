1.在IE浏览器下，禁止用户通过__proto__去修改实例上公有的属性和方法；这是IE浏览器的自我保护机制；
2.在所有浏览器下，禁止用户批量修改，实例上的公有属性和方法；
但是我们可以通过 类.prototype.xxx 进行一个个的修改；
  一个个修改，在标准浏览器下有两种方式：
  1）实例.__proto__.属性名（IE下不支持__proto__）;
  2）类.prototype.属性名
3.链式操作，我们关注的是前一个函数执行完成的“返回值”，返回的是个数组，后续就跟数组的方法，返回的是个数字，后续就跟数字的方法
补充：toFixed(要保留的小数的位数)：四舍五入的保留小数个数；
4.应该有的条件反射：
构造函数：构造函数中的this都是当前实例，构造函数中放的都是私有的属性和方法；
prototype：放的都是公有的属性和方法
类.prototype自己赋值一个对象，constructor一定会出问题；
5.数组去重：
    1.思路1：双重循环
    拿当前项跟他后面的每一项进行比较，如果相同，删除其中一个，一定要预防数组塌陷；
    2.思路2：创建新数组
    当新数组中没有重复的时候，才给新数组中放；
    3.思路3：利用对象不重名的特性；
    当对象中没有改属性的时候，赋值为1；
    当对象中已经有的该属性的时候，进行累加；
    注意：两个条件中直走一个：1）continue 2）if...else....
6.属性操作：
注意：判断属性是否在对象上，属性名一定要加引号，否则，会把他当做变量，报错！
1）in：判断是否为私有||公有属性
2）obj.hasOwnProperty(属性名)：判断是否有对象的私有属性；
3）自己封装hasPubProperty:判断某属性是否为对象的公有属性
    思路：该属性是对象上的属性 && 该属性不是对象的私有属性；
7.obj1.isPropertyOf(obj2):判断前一个对象，是否在后一个对象的原型链上；
8.call() 作用：改变this指向
call的第一个参数：改变call点前面的函数中的this指向；
call的第二个参数开始，对函数中的形参从左往右的赋值；
9.call继承：把父类私有的属性和方法，都继承给了子类私有的；
10.冒充继承：把父类私有+公有的属性和方法，都继承给了子类私有的；
11.原型链继承：把父类私有+公有的属性，都继承给了子类公有的；
12.拷贝继承：call继承+extend继承
extend（obj1,obj2）->让obj2克隆一份跟obj1一模一样的内容；
13.for。。。in循环：只能遍历对象身上自定义的属性和方法；
propertyIsEnumerable:只能遍历对象身上自定义的私有属性和方法；
hasOwnProperty:判断该属性是否为对象上的私有属性；












